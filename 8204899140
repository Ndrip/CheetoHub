
local get = function(x)
    return game:GetService(x)
end
local players = get "Players"
local ws = get "Workspace"
local rs = get "ReplicatedStorage"
local rus = get "RunService"
local uis = get "UserInputService"
local coregui = get "CoreGui"
local http = get "HttpService"
local ts = get "TeleportService"
local lighting = get "Lighting"
local plr = players.LocalPlayer
local char = (plr and (plr.Character or plr.CharacterAdded:Wait()) or nil)
local hrp = plr and (char:WaitForChild "HumanoidRootPart") or nil
local hum = plr and (char:WaitForChild "Humanoid") or nil
if plr then
    plr.CharacterAdded:Connect(
        function(c)
            char = c
            hrp = c:WaitForChild "HumanoidRootPart"
            hum = c:WaitForChild "Humanoid"
        end
    )
end
local cf = CFrame
local v3 = Vector3
local ud2 = UDim2
local c3 = Color3
local rgb = c3.fromRGB
local step = rus.Stepped
local rstep = rus.RenderStepped
local heartbeat = rus.Heartbeat
local function bind(k, callback)
    return uis.InputBegan:Connect(
        function(io, gpe)
            if Enum.UserInputType[k] then
                if io.UserInputType == Enum.UserInputType[k] then
                    callback()
                end
            elseif Enum.KeyCode[k] then
                if io.KeyCode == Enum.KeyCode[k] then
                    callback()
                end
            end
        end
    )
end
local function bindToStep(callback, doDebounce, debounceWait)
    local debounce = false
    step:Connect(
        function()
            if not debounce then
                debounce = doDebounce == nil
                callback()
                if debounceWait and doDebounce then
                    wait(debounceWait)
                end
                debounce = false
            end
        end
    )
end
local function bindToRenderStep(callback, doDebounce, debounceWait)
    local debounce = false
    rstep:Connect(
        function()
            if not debounce then
                debounce = doDebounce == nil
                callback()
                if debounceWait and doDebounce then
                    wait(debounceWait)
                end
                debounce = false
            end
        end
    )
end
local function bindToHeartbeat(callback, doDebounce, debounceWait)
    local debounce = false
    heartbeat:Connect(
        function()
            if not debounce then
                debounce = doDebounce == nil
                callback()
                if debounceWait and doDebounce then
                    wait(debounceWait)
                end
                debounce = false
            end
        end
    )
end
local JSON = {stringify = function(...)
        return http:JSONEncode(...)
    end, parse = function(...)
        return http:JSONDecode(...)
    end}
local tws = get "TweenService"
local stats = get("Stats")
local plrgui = plr:WaitForChild("PlayerGui")
local mouse = plr:GetMouse()
local models = ws.Models
local values = rs.Values
local carrier = values.Carrier
local status = values.Status
local playtype = values.PlayType
local thrown = values.Thrown
local qb = values.QB
local cc = ws.CurrentCamera
local finishLine = models.LockerRoomA.FinishLine
local initVoting = plrgui.MainGui.InitVoting
local mainRemote = rs.Remotes.CharacterSoundEvent
local function getPing()
    return stats.PerformanceStats.Ping:GetValue()
end
local function getServerPing()
    return stats.Network.ServerStatsItem["Data Ping"]:GetValue()
end
local function getPosInXSeconds(currentPos, direction, speed, seconds)
    local dist = speed * seconds
    local pos = currentPos + direction * dist
    return pos
end
local function getTime(dist, speed)
    return dist / speed
end
local function getJumpHeightFromJumpPower()
    return hum.JumpPower ^ 2 / (2 * ws.Gravity)
end
local function removeVectorComponent(vector, component)
    if component:lower() == "y" then
        return vector * v3.new(1, 0, 1)
    elseif component:lower() == "x" then
        return vector * v3.new(0, 1, 1)
    elseif component:lower() == "z" then
        return vector * v3.new(1, 1, 0)
    end
end
local function jump()
    hum.Jump = true
    keypress(0x20)
    wait()
    keyrelease(0x20)
end


wait(.1)

--[[ char.Humanoid.Died:Connect(function()
    game:GetService('TeleportService'):TeleportToPlaceInstance(game.PlaceId,game.JobId)
end) ]]

-- Functions
local function create(class, parent, props, children)
    props = props or {}
    children = children or {}
    parent = parent or nil
    local thing = Instance.new(class, parent)
    for i, v in pairs(props) do
        thing[i] = v
    end
    for _, v in pairs(children) do
        v.Parent = thing
    end
    return thing
end


if (not getrawmetatable or  not hookmetamethod or not Drawing.new) then
	game.Players.LocalPlayer:Kick("Your exploit is not supported. use Krnl (best free exploit) or Synapse X (best paid exploit) for it to work.") 
end

local uis = game:GetService("UserInputService")

local values = game:GetService("ReplicatedStorage").Values
local status = values.Status
local qb = values.QB
local isQB = (qb.Value == game:GetService("Players").LocalPlayer and game:GetService("Players").LocalPlayer.Character:FindFirstChild("Football"))


local get = function(x)
	return game:GetService(x)
end
local players = get "Players"
local ws = get "Workspace"
local rs = get "ReplicatedStorage"
local rus = get "RunService"
local uis = get "UserInputService"
local coregui = get "CoreGui"
local http = get "HttpService"
local ts = get "TeleportService"
local lighting = get "Lighting"
local plr = players.LocalPlayer
local char = (plr and (plr.Character or plr.CharacterAdded:Wait()) or nil)
local hrp = plr and (char:WaitForChild "HumanoidRootPart") or nil
local hum = plr and (char:WaitForChild "Humanoid") or nil
if plr then
	plr.CharacterAdded:Connect(
		function(c)
			char = c
			hrp = c:WaitForChild "HumanoidRootPart"
			hum = c:WaitForChild "Humanoid"
		end
	)
end

local cf = CFrame
local v3 = Vector3
local ud2 = UDim2
local c3 = Color3
local rgb = c3.fromRGB
local step = rus.Stepped
local rstep = rus.RenderStepped
local heartbeat = rus.Heartbeat
local function bind(k, callback)
	return uis.InputBegan:Connect(
		function(io, gpe)
			if Enum.UserInputType[k] then
				if io.UserInputType == Enum.UserInputType[k] then
					callback()
				end
			elseif Enum.KeyCode[k] then
				if io.KeyCode == Enum.KeyCode[k] then
					callback()
				end
			end
		end
	)
end
local tws = get "TweenService"
local stats = get("Stats")
local plrgui = plr:WaitForChild("PlayerGui")
local mouse = plr:GetMouse()
local models = ws.Models
local values = rs.Values
local carrier = values.Carrier
local status = values.Status
local playtype = values.PlayType
local thrown = values.Thrown
local qb = values.QB
local cc = ws.CurrentCamera
local finishLine = models.LockerRoomA.FinishLine
local initVoting = plrgui.MainGui.InitVoting
local mainRemote = rs.Remotes.CharacterSoundEvent








local mt = getrawmetatable(game)
setreadonly(mt,false)
local old = mt.__index

mt.__index = hookmetamethod(game,"__index",function(self,b)
	if self:IsA("Part") and b.Name == "Football" then
		return Vector3.new()
	end
	return old(s,b)
end)






local Connections = {}
local Objects = {}

--Objects
local Camera = workspace.CurrentCamera

--Services
local UIS = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local Mouse = LocalPlayer:GetMouse()

--Functions
local Drawing_new = Drawing.new
local Vector2_new = Vector2.new
local Color3_fromRGB = Color3.fromRGB
local Color3_fromHSV = Color3.fromHSV
local pairs = pairs
local next = next
local wrap = coroutine.wrap

local function IsVector2WithinDrawing(CursorPos, Obj)
	local X1, X2 = Obj.Position.X, Obj.Position.X + Obj.Size.X
	local Y1, Y2 = Obj.Position.Y, Obj.Position.Y + Obj.Size.Y
	return (CursorPos.X >= X1 and CursorPos.X <= X2) and (CursorPos.Y >= Y1 and CursorPos.Y <= Y2)
end

local function NewDrawing(Type, Prop)
	Prop = Prop or {}
	local Obj = Drawing_new(Type)
	for I, V in pairs(Prop) do
		Obj[I] = V
	end
	return Obj
end

--Const
local CursorSuccess, CursorData = pcall(game.HttpGet, game, "https://i.imgur.com/iYx753u.png")
local PickerSuccess, PickerData = pcall(game.HttpGet, game, "https://i.imgur.com/kFz7LMY.png")
local HueSuccess, HueData = pcall(game.HttpGet, game, "https://i.imgur.com/JAYh5cJ.png")
if not CursorSuccess or not PickerSuccess or not HueSuccess then
	error("Failed, Check The Links For the Assets")
end

local Library = {}
local Defaults = {
	MainOutlineColor = Color3_fromRGB(231, 125, 125),
	MainFrameColor = Color3_fromRGB(24, 24, 24),
	TitleColor = Color3_fromRGB(16, 16, 16),
	ButtonColor = Color3_fromRGB(32, 32, 32),
	ButtonEnabledColor = Color3_fromRGB(100, 255, 100),
	MouseColor = Color3_fromRGB(255, 100, 100),
	TextColor = Color3_fromRGB(255, 255, 255),
	Font = Drawing.Fonts.Monospace
}
function Library:CreateWindow(Title, X, Y, TitleHeight)
	local ViewportSize = Camera.ViewportSize
	local Size = Vector2_new(X, Y)
	local Center = Vector2_new(ViewportSize.X / 2 - Size.X / 2, ViewportSize.Y / 2 - Size.Y / 2)
	local Window = {}
	Window.CurrentCategory = nil
	Window.LastCategory = nil
	Window.LastMouseClickOnTitle = Vector2_new()
	Window.Categories = {}
	Window.Visible = true
	Window.BeingDragged = false
	Window.MainOutline = NewDrawing("Square", {
		Visible = true,
		Transparency = 1,
		Size = Size,
		Position = Center,
		Color = Defaults.MainOutlineColor,
		Thickness = 4,
		Filled = false
	})
	Window.TitleBar = NewDrawing("Square", {
		Visible = true,
		Transparency = 1,
		Size = Vector2_new(X, TitleHeight),
		Position = Center,
		Color = Defaults.TitleColor,
		Filled = true
	})
	Window.MainFrame = NewDrawing("Square", {
		Visible = true,
		Filled = true,
		Transparency = 1,
		Size = Vector2_new(X, Y - TitleHeight),
		Position = Vector2_new(Center.X, Center.Y + TitleHeight),
		Color = Defaults.MainFrameColor
	})
	Window.Title = NewDrawing("Text", {
		Visible = true,
		Transparency = 1,
		Color = Defaults.TextColor,
		Text = Title,
		Size = TitleHeight / 2,
		Center = false,
		Outline = true,
		Position = Window.TitleBar.Position + Vector2_new(8, TitleHeight / 4),
		Font = Defaults.Font
	})
	function Window:Move(X2, Y2)
		local MPos = Vector2_new(X2, Y2)
		Window.TitleBar.Position = MPos
		Window.MainOutline.Position = MPos
		Window.MainFrame.Position = Vector2_new(MPos.X, MPos.Y + TitleHeight)
		Window.Title.Position = Window.TitleBar.Position + Vector2_new(8, TitleHeight / 4)
		for i, t in next, Window.Categories do
			t.Toggle.Hitbox.Position = Window.MainOutline.Position + t.Toggle.Offset
			t.Toggle.Text.Position = Window.MainOutline.Position + t.Toggle.TextOffset
			t.Toggle.Line.From = Window.MainOutline.Position + Vector2.new(t.Toggle.Offset.X, TitleHeight * 1.75)
			t.Toggle.Line.To = Window.MainOutline.Position + Vector2.new(t.Toggle.Offset.X + t.Toggle.Hitbox.Size.X, TitleHeight * 1.75)
			for i, t in next, t.Objects do
				if t.Type == "Toggle" or t.Type == "Button" then
					t.Hitbox.Position = Window.MainOutline.Position + t.Offset
					t.Text.Position = Window.MainOutline.Position + t.TextOffset
				end
				if t.Type == "Slider" then
					t.Hitbox.Position = Window.MainOutline.Position + t.Offset
					t.Foreground.Position = Window.MainOutline.Position + t.Offset
					t.Text.Position = Window.MainOutline.Position + t.TextOffset
				end
				if t.Type == "Section" then
					t.Text.Position = Window.MainOutline.Position + t.TextOffset
					t.Line.From = Window.MainOutline.Position + Vector2_new(t.TextOffset.X + t.Text.TextBounds.X + t.Text.Size / 2, t.TextOffset.Y + t.Text.TextBounds.Y / 2)
					t.Line.To = Window.MainOutline.Position + Vector2_new(Window.MainOutline.Size.X - (X * .05), t.TextOffset.Y + t.Text.TextBounds.Y / 2)
				end
				if t.Type == "ComboBox" then
					t.Title.Position = Window.MainOutline.Position + t.TextOffset
					t.Hitbox.Position = Window.MainOutline.Position + t.Offset
					t.Text.Position = Window.MainOutline.Position + t.Offset
					local index = 1
					local DropdownSize = t.Offset.Y
					for i, t in next, t.Buttons do
						DropdownSize = DropdownSize + 20
						index = index + 1
						t.Hitbox.Position = Window.MainOutline.Position + Vector2_new(t.Offset.X, DropdownSize)
						t.Text.Position = Window.MainOutline.Position + Vector2_new(t.TextOffset.X, DropdownSize)
					end
				end
				if t.Type == "TextBox" then
					t.Hitbox.Position = Window.MainOutline.Position + t.Offset
					t.Text.Position = Window.MainOutline.Position + t.Offset
					t.Title.Position = Window.MainOutline.Position + t.TitleOffset
					t.Focused = false
					if t.InputConnection then
						t.InputConnection:Disconnect()
					end
				end
				if t.Type == "ColorPicker" then
					t.Categories.Position = Window.MainOutline.Position + t.CategoryOffset
					t.Picker.Position = Window.MainOutline.Position + t.PickerOffset
					t.Overlay.Position = Window.MainOutline.Position + t.PickerOffset
					t.Hue.Position = Window.MainOutline.Position + t.HueOffset
					for i, o in next, t.Items do
						o.BG.Position = Window.MainOutline.Position + (t.CategoryOffset + Vector2_new(0, o.MyOffset))
						o.Text.Position = Window.MainOutline.Position + (t.CategoryOffset + Vector2_new(0, o.MyOffset))
						o.ColorBG.Position = Window.MainOutline.Position + Vector2_new(t.CategoryOffset.x + (t.Categories.Size.x * .75), t.CategoryOffset.Y + o.MyOffset + 2)
					end
				end
			end
		end
	end
	function Window:ChangeCategory(Category)
		Window.LastCategory = Window.CurrentCategory
		Window.CurrentCategory = Category
		for i, t in next, Window.Categories do
			t.Toggle.Line.Visible = t == Category
			for i2, o in next, t.Objects do
				if o.Type == "Toggle" or o.Type == "Button" then
					o.Hitbox.Visible = t == Category
					o.Text.Visible = t == Category
				end
				if o.Type == "Slider" then
					o.Hitbox.Visible = t == Category
					o.Foreground.Visible = t == Category
					o.Text.Visible = t == Category
				end
				if o.Type == "Section" then
					o.Text.Visible = t == Category
					o.Line.Visible = t == Category
				end
				if o.Type == "ComboBox" then
					o.Hitbox.Visible = t == Category
					o.Text.Visible = t == Category
					o.Title.Visible = t == Category
					if o.Open and t ~= Category then
						o:Toggle()
					end
				end
				if o.Type == "TextBox" then
					o.Hitbox.Visible = t == Category
					o.Text.Visible = t == Category
					o.Title.Visible = t == Category
					o.Focused = false
					if t.InputConnection then
						t.InputConnection:Disconnect()
					end
				end
				if o.Type == "ColorPicker" then
					o.Categories.Visible = t == Category
					o.Picker.Visible = t == Category
					o.Overlay.Visible = t == Category
					o.Hue.Visible = t == Category
					for i3, o2 in next, o.Items do
						o2.BG.Visible = t == Category
						o2.Text.Visible = t == Category
						o2.ColorBG.Visible = t == Category
					end
				end
			end
		end
	end
	function Window:Toggle()
		Window.Visible = not Window.Visible
		Window.MainOutline.Visible = not Window.MainOutline.Visible
		Window.TitleBar.Visible = not Window.TitleBar.Visible
		Window.Title.Visible = not Window.Title.Visible
		Window.MainFrame.Visible = not Window.MainFrame.Visible
		Window.Mouse.Visible = not Window.Mouse.Visible
		Window.BeingDragged = false
		for i, t in next, Window.Categories do
			t.Toggle.Hitbox.Visible = Window.MainOutline.Visible
			t.Toggle.Text.Visible = Window.MainOutline.Visible
		end
		-- TODO: Add blur again without using blur effect
		if Window.Visible then
			Window:ChangeCategory(Window.LastCategory)
		else
			Window:ChangeCategory(nil)
			if Window.CurrentCategory ~= nil then
				for i, t in next, Window.CurrentCategory.Objects do
					if t.Type == "Textbox" then
						t.Focused = false
						if t.InputConnection then
							t.InputConnection:Disconnect()
						end
					end
				end
			end
		end
	end
	function Window:Init()
		for i, c in next, Window.Categories do
			for i, o in next, c.Objects do
				if o.Type == "ComboBox" then
					o:Init()
				end
			end
		end
		Window.Mouse = NewDrawing("Image", {
			Visible = true,
			Transparency = 1,
			Size = Vector2_new(36, 36),
			Position = UIS:GetMouseLocation(),
			Data = CursorData
		})
	end
	function Window:CreateCategory(name)
		local Category = {}
		Category.UISize = 0
		Category.Name = name
		Category.Toggle = {
			Type = "Toggle",
			Offset = Vector2_new((X / 5) * #Window.Categories, TitleHeight),
			TextOffset = Vector2_new((X / 5) * #Window.Categories + X / 10, TitleHeight * 1.15),
			Hitbox = NewDrawing("Square", {
				Visible = true,
				Transparency = 1,
				Filled = true,
				Size = Vector2_new(X / 5, TitleHeight * .75),
				Position = Window.MainOutline.Position + Vector2_new((X / 5) * #Window.Categories, TitleHeight),
				Color = Defaults.ButtonColor
			}),
			Text = NewDrawing("Text", {
				Visible = true,
				Text = name,
				Position = Window.MainOutline.Position + Vector2_new((X / 5) * #Window.Categories + X / 10, TitleHeight * 1.15),
				Size = TitleHeight * .5,
				Center = true,
				Color = Defaults.TextColor,
				Font = Defaults.Font,
				Outline = true
			}),
			Line = NewDrawing("Line", {
				Visible = false,
				Transparency = 1,
				Thickness = 1,
				Color = Defaults.MainOutlineColor,
				From = Window.MainOutline.Position + Vector2.new((X / 5) * #Window.Categories, TitleHeight * 1.75),
				To = Window.MainOutline.Position + Vector2.new(((X / 5) * #Window.Categories) + X / 5, TitleHeight * 1.75)
			})
		}
		Category.Objects = {}
		function Category:CreateSection(name)
			local Section = {
				Type = "Section",
				TextOffset = Vector2_new((X * .05), (TitleHeight * 2.3) + Category.UISize),
				Text = NewDrawing("Text", {
					Visible = true,
					Text = name,
					Font = Defaults.Font,
					Position = Window.MainOutline.Position + Vector2_new((X * .05), (TitleHeight * 2.3) + Category.UISize),
					Size = 18,
					Color = Defaults.TextColor,
					Outline = true
				}),
				Callback = callback,
				State = state
			}
			Section.Line = NewDrawing("Line", {
				Visible = true,
				Color = Defaults.MainOutlineColor,
				From = Window.MainOutline.Position + Vector2_new(Section.TextOffset.X + Section.Text.TextBounds.X + Section.Text.Size / 2, Section.TextOffset.Y + Section.Text.TextBounds.Y / 2),
				To = Window.MainOutline.Position + Vector2_new(Window.MainOutline.Size.X - (X * .05), Section.TextOffset.Y + Section.Text.TextBounds.Y / 2)
			})
			Category.UISize = Category.UISize + 24
			Category.Objects[#Category.Objects + 1] = Section
			return Toggle
		end
		function Category:CreateToggle(name, state, callback)
			local Toggle = {
				Type = "Toggle",
				Offset = Vector2_new((X * .05), (TitleHeight * 2.3) + Category.UISize),
				TextOffset = Vector2_new((X * .05) + 32, (TitleHeight * 2.3) + Category.UISize),
				Hitbox = NewDrawing("Square", {
					Visible = true,
					Transparency = 1,
					Filled = true,
					Size = Vector2_new(16, 16),
					Position = Window.MainOutline.Position + Vector2_new((X * .05), (TitleHeight * 2.3) + Category.UISize), -- This is stupid and bad there is a reason i am failing math fuck my life A
					Color = Defaults.ButtonColor
				}),
				Text = NewDrawing("Text", {
					Visible = true,
					Text = name,
					Font = Defaults.Font,
					Position = Window.MainOutline.Position + Vector2_new((X * .05) + 32, (TitleHeight * 2.3) + Category.UISize),
					Size = 16,
					Color = Defaults.TextColor,
					Outline = true
				}),
				Callback = callback,
				State = false
			}
			function Toggle.Toggle()
				Toggle.State = not Toggle.State
				callback(Toggle.State)
				Toggle.Hitbox.Color = Toggle.State and Defaults.MainOutlineColor or Defaults.ButtonColor
			end
			if Toggle.State ~= state then
				Toggle.Toggle()
			end
			Category.UISize = Category.UISize + 24
			Category.Objects[#Category.Objects + 1] = Toggle
			return Toggle
		end
		function Category:CreateSlider(name, minimum, maximum, state, callback)
			local Slider = {
				Type = "Slider",
				_min = minimum,
				_max = maximum,
				Amount = state,
				Offset = Vector2_new((X * .05), (TitleHeight * 2.3) + Category.UISize + 24),
				TextOffset = Vector2_new((X * .05), (TitleHeight * 2.3) + Category.UISize),
				Hitbox = NewDrawing("Square", {
					Visible = true,
					Transparency = 1,
					Filled = true,
					Size = Vector2_new((X * .9), 16),
					Position = Window.MainOutline.Position + Vector2_new((X * .05), (TitleHeight * 2.3) + Category.UISize + 24), -- This is stupid and bad there is a reason i am failing math fuck my life A
					Color = Defaults.ButtonColor
				}),
				Foreground = NewDrawing("Square", {
					Visible = true,
					Transparency = 1,
					Filled = true,
					Size = Vector2_new((X * .9) * (state / maximum), 16),
					Position = Window.MainOutline.Position + Vector2_new((X * .05), (TitleHeight * 2.3) + Category.UISize + 24),
					Color = Defaults.MainOutlineColor
				}),
				Text = NewDrawing("Text", {
					Visible = true,
					Text = name .. ": " .. state,
					Position = Window.MainOutline.Position + Vector2_new((X * .05), (TitleHeight * 2.3) + Category.UISize),
					Size = 16,
					Color = Defaults.TextColor,
					Font = Defaults.Font,
					Outline = true
				}),
				Callback = callback,
				State = state
			}
			Category.UISize = Category.UISize + 48
			function Slider.Slid(Amount)
				Slider.Amount = Amount
				Slider.Text.Text = name .. ": " .. Amount
				callback(Amount)
			end
			Slider.Slid(Slider.Foreground.Size.X)
			Category.Objects[#Category.Objects + 1] = Slider
			return Slider
		end
		function Category:CreateButton(name, callback)
			local Button = {
				Type = "Button",
				MaxValue = max_value,
				Offset = Vector2_new((X * .05), (TitleHeight * 2.3) + Category.UISize),
				TextOffset = Vector2_new((X * .05), (TitleHeight * 2.3) + Category.UISize),
				Hitbox = NewDrawing("Square", {
					Visible = true,
					Transparency = 1,
					Filled = true,
					Size = Vector2_new(X * .2, 20),
					Position = Window.MainOutline.Position + Vector2_new((X * .05), (TitleHeight * 2.3) + Category.UISize), -- This is stupid and bad there is a reason i am failing math fuck my life A
					Color = Defaults.ButtonColor
				}),
				Text = NewDrawing("Text", {
					Visible = true,
					Text = name,
					Position = Window.MainOutline.Position + Vector2_new((X * .05), (TitleHeight * 2.3) + Category.UISize),
					Size = 20,
					Color = Defaults.TextColor,
					Font = Defaults.Font,
					Outline = true
				}),
				Callback = callback,
				State = state
			}
			Category.UISize = Category.UISize + 24
			Button.Hitbox.Size = Button.Text.TextBounds
			Category.Objects[#Category.Objects + 1] = Button
			return Button
		end
		function Category:CreateTextBox(name, callback)
			local TextBox = {
				Type = "TextBox",
				Focused = false,
				Offset = Vector2_new((X * .05), (TitleHeight * 2.3) + Category.UISize),
				TitleOffset = Vector2_new((X * .05), (TitleHeight * 2.3) + Category.UISize),
				Hitbox = NewDrawing("Square", {
					Visible = true,
					Transparency = 1,
					Filled = true,
					Size = Vector2_new(X * .65, 20),
					Position = Window.MainOutline.Position + Vector2_new((X * .05), (TitleHeight * 2.3) + Category.UISize), -- This is stupid and bad there is a reason i am failing math fuck my life A
					Color = Defaults.ButtonColor
				}),
				Title = NewDrawing("Text", {
					Visible = true,
					Text = name,
					Position = Window.MainOutline.Position + Vector2_new((X * .05), (TitleHeight * 2.3) + Category.UISize),
					Size = 20,
					Color = Defaults.TextColor,
					Font = Defaults.Font,
					Outline = true
				}),
				Text = NewDrawing("Text", {
					Visible = true,
					Text = "",
					Position = Window.MainOutline.Position + Vector2_new((X * .05), (TitleHeight * 2.3) + Category.UISize),
					Size = 20,
					Color = Defaults.TextColor,
					Font = Defaults.Font,
					Outline = true
				}),
				Callback = callback,
				State = state
			}
			TextBox.Title.Position = TextBox.Title.Position + Vector2_new(TextBox.Hitbox.Size.X + (X * .025))
			TextBox.TitleOffset = Vector2_new((X * .05), (TitleHeight * 2.3) + Category.UISize) + Vector2_new(TextBox.Hitbox.Size.X + (X * .025))
			Category.UISize = Category.UISize + 24
			Category.Objects[#Category.Objects + 1] = TextBox
			return Button
		end
		function Category:CreateColorPicker(Items, Callback)
			local ColorPicker = {
				Type = "ColorPicker",
				SelectedItem = "",
				Callback = Callback,
				HueDragged = false,
				PickerDragged = false,
				CategoryOffset = Vector2_new((X * .05), (TitleHeight * 2.3) + Category.UISize),
				PickerOffset = Vector2_new((X * .05) + X * .31, (TitleHeight * 2.3) + Category.UISize),
				HueOffset = Vector2_new((X * .05) + X * .31, ((TitleHeight * 2.3) + Category.UISize) + ((X * .59) - 46)),
				Items = {},
				ItemOffset = 0,
				Categories = NewDrawing("Square", {
					Visible = true,
					Transparency = 1,
					Position = Window.MainOutline.Position + Vector2_new((X * .05), (TitleHeight * 2.3) + Category.UISize),
					Size = Vector2.new(X * .3, (X * .59) - 30),
					Filled = true,
					Color = Defaults.TitleColor
				}),
				Picker = NewDrawing("Square", {
					Visible = true,
					Transparency = 1,
					Position = Window.MainOutline.Position + Vector2_new((X * .05) + X * .31, (TitleHeight * 2.3) + Category.UISize),
					Size = Vector2.new(X * .59, (X * .59) - 48),
					Filled = true,
					Color = Color3_fromHSV(.5, 1, 1)
				}),
				Overlay = NewDrawing("Image", {
					Visible = true,
					Transparency = 1,
					Position = Window.MainOutline.Position + Vector2_new((X * .05) + X * .31, (TitleHeight * 2.3) + Category.UISize),
					Data = PickerData,
					Size = Vector2.new(X * .59, (X * .59) - 48)
				}),
				Hue = NewDrawing("Image", {
					Visible = true,
					Transparency = 1,
					Position = Window.MainOutline.Position + Vector2_new((X * .05) + X * .31, ((TitleHeight * 2.3) + Category.UISize) + ((X * .59) - 46)),
					Data = HueData,
					Size = Vector2.new(X * .59, 16)
				})
			}
			function ColorPicker:ForceColor(c)
				if ColorPicker.Items[ColorPicker.SelectedItem] ~= nil then
					local h = c:ToHSV()
					ColorPicker.Picker.Color = Color3_fromHSV(h, 1, 1)
					ColorPicker.Items[ColorPicker.SelectedItem].ColorBG.Color = c
				end
			end
			local first_item = true
			for i, t in next, Items do
				local category = {
					MyOffset = ColorPicker.ItemOffset,
					Color = t,
					BG = NewDrawing("Square", {
						Visible = true,
						Transparency = first_item and 1 or 0,
						Filled = true,
						Position = Window.MainOutline.Position + Vector2_new(ColorPicker.CategoryOffset.x, ColorPicker.CategoryOffset.Y + ColorPicker.ItemOffset),
						Size = Vector2.new(ColorPicker.Categories.Size.x, 20),
						Color = Defaults.ButtonColor
					}),
					Text = NewDrawing("Text", {
						Visible = true,
						Text = tostring(i),
						Transparency = 1,
						Position = Window.MainOutline.Position + Vector2_new(ColorPicker.CategoryOffset.x, ColorPicker.CategoryOffset.Y + ColorPicker.ItemOffset),
						Size = 20,
						Color = Defaults.TextColor,
						Font = Defaults.Font,
						Outline = true
					}),
					ColorBG = NewDrawing("Square", {
						Visible = true,
						Transparency = 1,
						Filled = true,
						Position = Window.MainOutline.Position + Vector2_new(ColorPicker.CategoryOffset.x + (ColorPicker.Categories.Size.x * .75), ColorPicker.CategoryOffset.Y + ColorPicker.ItemOffset + 2),
						Size = Vector2.new(ColorPicker.Categories.Size.x * .2, 16),
						Color = t
					})
				}
				ColorPicker.ItemOffset = ColorPicker.ItemOffset + 20
				ColorPicker.Items[i] = category
				if first_item then
					ColorPicker.SelectedItem = i
				end
				first_item = false
			end
			Category.UISize = Category.UISize + ColorPicker.CategoryOffset.y + 24
			Category.Objects[#Category.Objects + 1] = ColorPicker
			return ColorPicker
		end
		function Category:CreateComboBox(name, callback, things, index)
			local ComboBox = {
				Type = "ComboBox",
				MaxValue = max_value,
				Item = things[1],
				Open = false,
				DropdownSize = (TitleHeight * 2.3) + Category.UISize + 24,
				Offset = Vector2_new((X * .05), (TitleHeight * 2.3) + Category.UISize + 24),
				TextOffset = Vector2_new((X * .05), (TitleHeight * 2.3) + Category.UISize + 4),
				Callback = callback,
				Title = NewDrawing("Text", {
					Visible = true,
					Transparency = 1,
					Text = name,
					Position = Window.MainOutline.Position + Vector2_new((X * .05), (TitleHeight * 2.3) + Category.UISize + 4),
					Size = 16,
					Color = Defaults.TextColor,
					Font = Defaults.Font,
					Outline = true
				}),
				Hitbox = NewDrawing("Square", {
					Visible = true,
					Transparency = 1,
					Filled = true,
					Size = Vector2_new(X * .4, 20),
					Position = Window.MainOutline.Position + Vector2_new((X * .05), (TitleHeight * 2.3) + Category.UISize + 24), -- This is stupid and bad there is a reason i am failing math fuck my life A
					Color = Defaults.ButtonColor
				}),
				Text = NewDrawing("Text", {
					Visible = true,
					Text = things[1],
					Position = Window.MainOutline.Position + Vector2_new((X * .05), (TitleHeight * 2.3) + Category.UISize + 24),
					Size = 20,
					Color = Defaults.TextColor,
					Font = Defaults.Font,
					Outline = true
				}),
				Buttons = {},
				State = state
			}
			for i, t in next, things do
				if t == index then
					ComboBox.Item = t
					ComboBox.Text.Text = t
				end
			end
			function ComboBox:Init()
				for i, t in next, things do
					ComboBox.DropdownSize = ComboBox.DropdownSize + 20
					local Button = {
						Type = "Button",
						MaxValue = max_value,
						Offset = Vector2_new((X * .05), ComboBox.DropdownSize),
						TextOffset = Vector2_new((X * .05), ComboBox.DropdownSize),
						Callback = callback,
						Hitbox = NewDrawing("Square", {
							Visible = false,
							Transparency = 1,
							Filled = true,
							Size = Vector2_new(X * .4, 20),
							Position = Window.MainOutline.Position + Vector2_new((X * .05), ComboBox.DropdownSize), -- This is stupid and bad there is a reason i am failing math fuck my life A
							Color = Defaults.ButtonColor
						}),
						Text = NewDrawing("Text", {
							Visible = false,
							Text = t,
							Position = Window.MainOutline.Position + Vector2_new((X * .05), ComboBox.DropdownSize),
							Size = 20,
							Color = Defaults.TextColor,
							Font = Defaults.Font,
							Outline = true
						}),
						State = state
					}
					ComboBox.Buttons[t] = Button
				end
			end
			function ComboBox:Toggle()
				ComboBox.Open = not ComboBox.Open
				for i, t in next, ComboBox.Buttons do
					t.Hitbox.Visible = ComboBox.Open
					t.Text.Visible = ComboBox.Open
				end
			end
			Category.UISize = Category.UISize + 48
			Category.Objects[#Category.Objects + 1] = ComboBox
			return ComboBox
		end
		Window.Categories[#Window.Categories + 1] = Category
		Index = #Window.Categories
		return Category
	end
	Connections.InputBegan = UIS.InputBegan:Connect(function(_)
		if _.UserInputType == Enum.UserInputType.MouseButton1 and IsVector2WithinDrawing(UIS:GetMouseLocation(), Window.TitleBar) and Window.Visible then
			Window.BeingDragged = true
			Window.LastMouseClickOnTitle = UIS:GetMouseLocation()
		end
		if _.UserInputType == Enum.UserInputType.MouseButton1 then
			for i, t in next, Window.Categories do
				if Window.Visible and IsVector2WithinDrawing(UIS:GetMouseLocation(), t.Toggle.Hitbox) then
					Window:ChangeCategory(t)
					break
				end
			end
			if Window.CurrentCategory then
				for i, o in next, Window.CurrentCategory.Objects do
					if o.Type == "ComboBox" and o.Open then
						local finished = false
						for i, b in next, o.Buttons do
							if IsVector2WithinDrawing(UIS:GetMouseLocation(), b.Hitbox) then
								o.Item = b.Text.Text
								o.Text.Text = o.Item
								o:Toggle()
								wrap(o.Callback)(o.Item)
								finished = true
							end
						end
						if finished then
							break
						end
					end
					if (o.Type == "Toggle" or o.Type == "ComboBox") and IsVector2WithinDrawing(UIS:GetMouseLocation(), o.Hitbox) then
						o:Toggle()
						break
					end
					if o.Type == "Button" and IsVector2WithinDrawing(UIS:GetMouseLocation(), o.Hitbox) then
						o.Callback()
					end
					if o.Type == "Slider" and IsVector2WithinDrawing(UIS:GetMouseLocation(), o.Hitbox) then
						o.BeingDragged = true
						RunService:BindToRenderStep("DragSlider", 1, function()
							if o.BeingDragged then
								local newval = (Mouse.X - o.Hitbox.Position.X) / o.Hitbox.Size.X
								newval = math.clamp(newval, 0, 1)
								local v = math.floor(o._min + (o._max - o._min) * newval)
								v = math.floor(v * 10) / 10
								o.Foreground.Size = Vector2_new(newval * o.Hitbox.Size.X, o.Hitbox.Size.Y)
								o.Slid(v)
							else
								RunService:UnbindFromRenderStep("DragSlider")
							end
						end)
					end
					if o.Type == "ColorPicker" then
						if IsVector2WithinDrawing(UIS:GetMouseLocation(), o.Hue) then
							o.HueDragged = true
							RunService:BindToRenderStep("DragHue", 1, function()
								if o.HueDragged then
									local percent = (Mouse.X - o.Hue.Position.X) / o.Hue.Size.X
									percent = math.clamp(percent, 0, 1)
									o.Picker.Color = Color3_fromHSV(percent, 1, 1)
									if o.Items[o.SelectedItem] ~= nil then
										local _, s, v = o.Items[o.SelectedItem].Color:ToHSV()
										o.Items[o.SelectedItem].ColorBG.Color = Color3_fromHSV(percent, s, v)
										o.Items[o.SelectedItem].Color = Color3_fromHSV(percent, s, v)
										o.Callback(o.Items[o.SelectedItem].Color)
									end
								else
									RunService:UnbindFromRenderStep("DragHue")
								end
							end)
							break
						end
						if IsVector2WithinDrawing(UIS:GetMouseLocation(), o.Picker) then
							o.PickerDragged = true
							RunService:BindToRenderStep("DragPicker", 1, function()
								if o.PickerDragged then
									local MouseLocation = UIS:GetMouseLocation()
									local percentx = (MouseLocation.X - o.Picker.Position.X) / o.Picker.Size.X
									local percenty = ((o.Picker.Position.Y + o.Picker.Size.Y) - MouseLocation.Y) / o.Picker.Size.Y
									percentx = math.clamp(percentx, 0, 1)
									percenty = math.clamp(percenty, 0, 1)
									if o.Items[o.SelectedItem] ~= nil then
										local h = o.Picker.Color:ToHSV()
										o.Items[o.SelectedItem].ColorBG.Color = Color3_fromHSV(h, percentx, percenty)
										o.Items[o.SelectedItem].Color = Color3_fromHSV(h, percentx, percenty)
										o.Callback(o.Items[o.SelectedItem].Color)
									end
								else
									RunService:UnbindFromRenderStep("DragPicker")
								end
							end)
							break
						end
						for i2, o2 in next, o.Items do
							if IsVector2WithinDrawing(UIS:GetMouseLocation(), o2.BG) then
								o.SelectedItem = i2
								o2.BG.Transparency = 1 -- GET OUT OF MY HEAD  GET OUT OF MY HEAD  GET OUT OF MY HEAD  GET OUT OF MY HEAD  GET OUT OF MY HEAD  GET OUT OF MY HEAD  GET OUT OF MY HEAD  GET OUT OF MY HEAD  GET OUT OF MY HEAD
								for i3, o3 in next, o.Items do
									if o3 ~= o2 then
										o3.BG.Transparency = 0
									end
								end
								break
							end
						end
					end
					if o.Type == "TextBox" and IsVector2WithinDrawing(UIS:GetMouseLocation(), o.Hitbox) then
						o.Focused = true
						o.InputConnection = UIS.InputBegan:Connect(function(_, GP)
							if _.UserInputType == Enum.UserInputType.Keyboard then
								if _.KeyCode == Enum.KeyCode.Return then
									o.Callback(o.Text.Text)
									o.Focused = false
									o.InputConnection:Disconnect()
								end
								if _.KeyCode == Enum.KeyCode.Space then
									o.Text.Text = o.Text.Text .. " "
								end
								if _.KeyCode == Enum.KeyCode.Backspace then
									o.Text.Text = string.sub(o.Text.Text, 1, #o.Text.Text - 1)
								end
								if _.KeyCode ~= Enum.KeyCode.Backspace and #(tostring(_.KeyCode)) == 14 then
									o.Text.Text = o.Text.Text .. string.sub(tostring(_.KeyCode), 14, 14)
								end
							end
						end)
					elseif o.Type == "TextBox" and o.Focused then
						o.Callback(o.Text.Text)
						o.InputConnection:Disconnect()
						o.Focused = false
					end
				end
			end
		end
		if _.UserInputType == Enum.UserInputType.Keyboard and _.KeyCode == Enum.KeyCode.LeftAlt then
			Window:Toggle()
		end
	end)
	Connections.InputEnded = UIS.InputEnded:Connect(function(_)
		if _.UserInputType == Enum.UserInputType.MouseButton1 then
			Window.BeingDragged = false
			if Window.CurrentCategory then
				for i, o in next, Window.CurrentCategory.Objects do
					if o.Type == "Slider" then
						o.BeingDragged = false
					end
					if o.Type == "ColorPicker" then
						o.HueDragged = false
						o.PickerDragged = false
					end
				end
			end
		end
	end)
	Connections.OnMouseMove = UIS.InputChanged:Connect(function(_)
		if Window.Mouse and _.UserInputType == Enum.UserInputType.MouseMovement then
			Window.Mouse.Visible = (IsVector2WithinDrawing(UIS:GetMouseLocation(), Window.MainFrame) or IsVector2WithinDrawing(UIS:GetMouseLocation(), Window.TitleBar)) and Window.Visible
			Window.Mouse.Position = UIS:GetMouseLocation() - Window.Mouse.Size / 2
			if Window.BeingDragged then
				local Delta = (UIS:GetMouseLocation() - Window.LastMouseClickOnTitle)
				Window.LastMouseClickOnTitle = UIS:GetMouseLocation()
				Window:Move(Window.MainOutline.Position.X + Delta.X, Window.MainOutline.Position.Y + Delta.Y)
			end
		end
	end)
	Objects.Window = Window
	return Window
end

local MainWindow = Library:CreateWindow("Football Fusion 2", 500, 620, 32)
local Catching = MainWindow:CreateCategory("Catching")
local Physics = MainWindow:CreateCategory("Physics")
local QB = MainWindow:CreateCategory("QB")
local Visuals = MainWindow:CreateCategory("Visuals")
local Extras = MainWindow:CreateCategory("Trolling")


Catching:CreateSlider("Mags Distance",1,100,0,function(value)
    distance = value
end)





Catching:CreateToggle("Football Reach (Mag Script)",false,function(value)
	_G.tog = value
    magging = nil;
    
uis.InputBegan:Connect(function(key,gp)
    		if  key.UserInputType == Enum.UserInputType.MouseButton1 or key.KeyCode == Enum.KeyCode.ButtonR2 and gp == false and status.Value == "InPlay" and isQB == false and _G.tog == true then
			for _,k in pairs(game:GetService("Workspace"):GetChildren()) do
				if k.Name == "Football" and k.ClassName == "Part" then
					for i = 1,60 do wait()
					    magging = true
					    if game:GetService("Players").LocalPlayer.Character:FindFirstChild("HumanoidRootPart") and (game:GetService("Players").LocalPlayer.Character.HumanoidRootPart.Position - k.Position).Magnitude <= distance and status.Value == "InPlay" and isQB == false and _G.tog == true then
					        if gp == false then
							k.CFrame = CFrame.new(game:GetService("Players").LocalPlayer.Character.Head.Position)
							firetouchinterest(game:GetService("Players").LocalPlayer.Character.Head,k,0)
							firetouchinterest(game:GetService("Players").LocalPlayer.Character.Head,k,1)
							k.CanCollide = false
							end
						end
					end
					magging = false
				end
			end
		end
	end)
end)



Catching:CreateToggle("Stable Football Mags (Use if you crash with normal mags)",false,function(value)
	_G.tog2 = value
    magging = nil;
    
uis.InputBegan:Connect(function(key,gp)
    		if  key.UserInputType == Enum.UserInputType.MouseButton1 or key.KeyCode == Enum.KeyCode.ButtonR2 and gp == false and status.Value == "InPlay" and isQB == false and _G.tog2 == true then
			for _,k in pairs(game:GetService("Workspace"):GetChildren()) do
				if k.Name == "Football" and k.ClassName == "Part" then
					for i = 1,60 do wait()
					    magging = true
					    if game:GetService("Players").LocalPlayer.Character:FindFirstChild("HumanoidRootPart") and (game:GetService("Players").LocalPlayer.Character.HumanoidRootPart.Position - k.Position).Magnitude <= distance and status.Value == "InPlay" and isQB == false and _G.tog2 == true then
					        if gp == false then
							k.CFrame = CFrame.new(game:GetService("Players").LocalPlayer.Character.Head.Position)

							k.CanCollide = false
							end
						end
					end
					magging = false
				end
			end
		end
	end)
end)




Physics:CreateToggle("Auto Hands",false,function(value)
	tog2 = value
	rus.Stepped:Connect(function()
		local fb = game:GetService("Workspace"):FindFirstChild("Football")
		if fb and tog2 == true then
			if tog2 == true and
				values.Status.Value == "InPlay" and values.QB.Value ~= game:GetService("Players").LocalPlayer and
				values.PlayType.Value == "normal" and
				(hrp.Position - fb.Position).Magnitude <= 20
			then
				mouse1click()
			end
		elseif
			values.Carrier.Value and values.QB.Value and
			values.QB.Value == values.Carrier.Value and
			values.Carrier.Value.Team ~= plr.Team and
			(values.QB.Value.Character.HumanoidRootPart.Position - hrp.Position).Magnitude <= 30
		then
			repeat
				step:wait()
			until thrown.Value
		end
	end)
end)


Physics:CreateToggle("Auto Jump",false,function(value)
	tog3 = value
	local function removeVectorComponent(vector, component)
    if component:lower() == "y" then
        return vector * v3.new(1, 0, 1)
    elseif component:lower() == "x" then
        return vector * v3.new(0, 1, 1)
    elseif component:lower() == "z" then
        return vector * v3.new(1, 1, 0)
    end
end

local function getJumpHeightFromJumpPower()
    return hum.JumpPower ^ 2 / (2 * ws.Gravity)
end


local function jump()
    hum.Jump = true
    keypress(0x20)
    wait()
    keyrelease(0x20)
end

coroutine.resume(
    coroutine.create(
        function()
            repeat
                wait(.25)
            until tog3 == false
            while rstep:wait() do
                if tog3 == true then
                    local fb = ws:FindFirstChild("Football")
                    if status.Value == "InPlay" and fb then
                        local fbpos = fb.Position
                        if fbpos.Y >= 7 and fbpos.Y <= hrp.Position.Y + getJumpHeightFromJumpPower() + 10 then
                            local distXZ =
                                (removeVectorComponent(fb.Position, "Y") - removeVectorComponent(hrp.Position, "Y")).Magnitude
                            local distX = (fb.Position * v3.new(1, 0, 0) - hrp.Position * v3.new(1, 0, 0)).Magnitude
                            local distZ = (fb.Position * v3.new(0, 0, 1) - hrp.Position * v3.new(0, 0, 1)).Magnitude
                            if distX <= 10 and distZ <= fb.Position.Y then
                                jump()
                            end
                        end
                    end
                end
            end
        end
    )
)


end)


 
 QB:CreateToggle("Qb Aimbot (Press T to Throw)",false,function(value)
     tog5 = value
     local uis = game:GetService("UserInputService")

local LPlayer = game:GetService("Players").LocalPlayer
local LMouse = LPlayer:GetMouse()

local Camera = game:GetService("Workspace").CurrentCamera

local function GetClosestPlayer()
    local ClosestDistance, ClosestPlayer = math.huge, nil;
    for _,Player in next, game:GetService("Players"):GetPlayers() do
        if Player ~= LPlayer and Player.TeamColor == LPlayer.TeamColor then
            local Character = Player.Character
            if Character and Character.Humanoid.Health > 1 then
                local ScreenPosition, IsVisibleOnViewPort = Camera:WorldToViewportPoint(Character.HumanoidRootPart.Position)
                if IsVisibleOnViewPort then
                    local MDistance = (Vector2.new(LMouse.X, LMouse.Y) - Vector2.new(ScreenPosition.X, ScreenPosition.Y)).Magnitude
                    if MDistance < ClosestDistance then
                        ClosestPlayer = Player
                        ClosestDistance = MDistance
                    end
                end
            end
        end
    end
    return ClosestPlayer
end


uis.InputBegan:Connect(function(key)
    if key.KeyCode == Enum.KeyCode.T and tog5 == true then
         getgenv().closest = GetClosestPlayer()
         if getgenv().closest.TeamColor == game:GetService("Players").LocalPlayer.TeamColor then
local plusvector = tonumber((game:GetService("Players").LocalPlayer.Character.HumanoidRootPart.Position - getgenv().closest.Character.HumanoidRootPart.Position).Magnitude)
local pwr = string.gsub(game:GetService("Players").LocalPlayer.PlayerGui.BallGui.Frame.Disp.Text,"%%","")

local args = {
    [1] = "Clicked",
    [2] = game:GetService("Players").LocalPlayer.Character.HumanoidRootPart.Position,
    [3] = getgenv().closest.Character["HumanoidRootPart"].Position + Vector3.new(0,plusvector,0),
    [4] = tonumber(math.round(pwr))
}

game:GetService("Players").LocalPlayer.Character.Football.Handle.RemoteEvent:FireServer(unpack(args))
        end
    end
end)

 end)
 
 Physics:CreateToggle("Forward Teleport 2 Studs, Keybind is F",false,function(value)
     forwardtp = value
     
     local Players = game:GetService("Players")
local ContextActionService = game:GetService("ContextActionService")
 
local function doTeleport()
    if forwardtp == true then
	local player = Players.LocalPlayer
	local character = player.Character
	if character and character.Parent then
		local currentPivot = character:GetPivot()
		character:PivotTo(currentPivot * CFrame.new(0, 0, -2))
		end
	end
end
 _G.tog = value
 if _G.tog == true  then
ContextActionService:BindAction("Teleport", doTeleport, true, Enum.KeyCode.F)
else
    ContextActionService:UnbindAction("Teleport")
end
 end)
 
 
 
 
 Physics:CreateButton("Anti Jam",function()
	tog4 = value
		local function setCollisionsForPart(v)
			coroutine.resume(
				coroutine.create(
					function()
						local isBasePart,_ = 
							pcall(function()
								return v.CanCollide
							end)
						if isBasePart then
							local oldCanCllide = v.CanCollide
							while step:wait() and v:IsA("BasePart") do
								local enabled = tog3
								if enabled and ws:FindFirstChild("Football") and status.Value == "InPlay" and playtype.Value ~= "fieldgoal" then
									v.CanCollide = false
								else
									v.CanCollide = oldCanCllide
								end
							end
						end
					end)
			)
		end
	end)

Catching:CreateSlider("Pull Vector Distance",1,25,0,function(value)
    pulldist = value
end)

 function create(class, parent, props, children)
    props = props or {}
    children = children or {}
    parent = parent or nil
    local thing = Instance.new(class, parent)
    for i, v in pairs(props) do
        thing[i] = v
    end
    for _, v in pairs(children) do
        v.Parent = thing
    end
    return thing
end

 Catching:CreateToggle("Pull Vector",false,function(value)
     pullvector = value
     
         local function getball()
                return workspace:FindFirstChild("Football")
         end
        
uis.InputBegan:Connect(function(key,gp)
    if key.UserInputType == Enum.UserInputType.MouseButton1 and pullvector == true then
                    pcall(
                        function()
                            char["Catch Left"].Size = char["Catch Left"].Size.Unit * 10
                            char["Catch Right"].Size = char["Catch Right"].Size.Unit * 10
                        end
                    )
                    local balltppart =
                        create(
                        "Part",
                        ws,
                        {
                            Anchored = true,
                            CanCollide = false,
                            Transparency = 1,
                            Size = v3.new(1, 1, 1)
                        }
                    )
                    local fb = getball()
                    
                    local function create(class, parent, props, children)
    props = props or {}
    children = children or {}
    parent = parent or nil
    local thing = Instance.new(class, parent)
    for i, v in pairs(props) do
        thing[i] = v
    end
    for _, v in pairs(children) do
        v.Parent = thing
    end
    return thing
end



                    local function check1()
                        return getball() and status.Value == "InPlay" and qb.Value ~= plr
                    end
                    if check1() and (fb.Position - hrp.Position).Magnitude <= pulldist then
                        balltppart.Position = fb.Position
                        fb.Size = fb.Size.Unit * 10
                        local p1 = fb.Position
                        wait(.1)
                        local p2 = fb.Position
                        local dir = (p2 - p1).Unit
                        local ping = getPing() * 2 + getServerPing()
                        local att0 = create("Attachment", hrp)
                        local att1 =
                            create(
                            "Attachment",
                            balltppart,
                            {
                                Position = pos
                            }
                        )
                        local rope =
                            create(
                            "RopeConstraint",
                            balltppart,
                            {
                                Length = 0,
                                Restitution = 0,
                                Attachment0 = att0,
                                Attachment1 = att1,
                                Enabled = true
                            }
                        )
                        repeat
                            if playtype.Value == "normal" then
                                local p1 = fb.Position
                                wait(.1)
                                local p2 = fb.Position
                                local dir = (p2 - p1).Unit
                                local pos = getPosInXSeconds(fb.Position, dir, fb.Velocity.Magnitude, ping / 1000)
                                balltppart.Position = pos
                            else
                                balltppart.Position = fb.Position
                            end
                            step:wait()
                        until status.Value == "DeadPlay" or not getball()
                        att0:Destroy()
                        att1:Destroy()
                        rope:Destroy()
                        balltppart:Destroy()
            end
        end
    end)
end)
 
local ESP = loadstring(game:HttpGet("https://kiriot22.com/releases/ESP.lua"))()



Visuals:CreateToggle("Football ESP",false,function(value)
     



ESP:AddObjectListener(workspace, {
    Name = "Football",
    CustomName = "Football",
    Color = Color3.fromRGB(255,255,255),
    IsEnabled = "FootballESP"
})

ESP.FootballESP = true

footballesp = value
ESP:Toggle(footballesp)
 end)
 
 Visuals:CreateToggle("Player ESP",false,function(value)
     players = value
        if not ESP.FootballESP == true then
     ESP:Toggle(true)
        end
 
     ESP.Players = players
 end)
 
 Visuals:CreateToggle("ESP Boxes",false,function(value)
     ESP.Boxes = value
 end)
 Visuals:CreateToggle("Use Team Color",false,function(value)
     ESP.TeamColor = value
 end)
 
 Extras:CreateToggle("Advertise Script in Chat",false,function(value)
     Advertise = value

 end)

spawn(function()
         while true do wait(2)
             if Advertise then
local ohString1 = "use cheeto hub for the best hacks for football fusion 2, inv: .gg/Cp4U3xtApN"
local ohString2 = "All"

game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer(ohString1, ohString2)
        end
    end
end)

     local oldCanCollide = workspace:FindFirstChild("ScrambleWall").CanCollide

Extras:CreateToggle("No QB Boundaries",false,function(value)
    boundaries = value 

    if boundaries  == true then
        workspace:FindFirstChild("ScrambleWall").CanCollide = false
     else
        workspace:FindFirstChild("ScrambleWall").CanCollide = oldCanCollide
    end
end)
     local oldParent = workspace.Models

 Extras:CreateToggle("No Out Of Bounds",false,function(value)
     bounds = value

      if bounds == true then
        if workspace.Models:FindFirstChild("Boundaries") then
            workspace.Models:FindFirstChild("Boundaries").Parent = game:GetService("BadgeService")
        elseif bounds == false then
            game:GetService("BadgeService"):FindFirstChild("Boundaries").Parent = workspace.Models
        end
    end           
end)
 

 
MainWindow:Init()
MainWindow:ChangeCategory(Main)
